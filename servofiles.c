#pragma config(Sensor, in1,    gyroDrive,      sensorGyro)
#pragma config(Sensor, in2,    gyroArm,        sensorGyro)
#pragma config(Motor,  port1,           backRightWheel, tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           leftClawArm,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           frontLeftWheel, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           leftRotate,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           goalLift,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           Claw,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           rightRotate,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           frontRightWheel, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           backLeftWheel, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          rightClawArm,  tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void moveStraight(int power, int counts); //headers
void moveSideways(int power, int counts); //headers
void turn (int degrees);
void clearEncoder();
void clearGyros ();

task main()
{



}
void moveUp(int power,int time)
{
	motor[frontRightWheel] = power;
	motor[frontLeftWheel] = power;
	motor[backRightWheel] = power;
	motor[backLeftWheel] = power;
	wait1Msec(time);
}

void clearGyros()
{
	SensorType[gyroDrive] = sensorNone;
	wait1Msec(1000);
	//Reconfigure Analog Port 8 as a Gyro sensor and allow time for ROBOTC to calibrate it
	SensorType[gyroDrive] = sensorGyro;
	wait1Msec(2000);

	SensorType[gyroArm] = sensorNone;
	wait1Msec(1000);
	//Reconfigure Analog Port 8 as a Gyro sensor and allow time for ROBOTC to calibrate it
	SensorType[gyroArm] = sensorGyro;
	wait1Msec(2000);
}

void turn(int degrees )
{
	//Specify the number of degrees for the robot to turn (1 degree = 10, or 900 = 90 degrees)
	int degrees10 = degrees*10;
	//Specify the amount of acceptable error in the turn
	int error = 5;
	//While the absolute value of the gyro is less than the desired rotation - 100...
	//if (degrees > 0)
	//{
	while(abs(SensorValue[gyroDrive]) < degrees10 - 100)
	{
		motor[frontRightWheel] = 50;
		motor[frontLeftWheel] = -50;
		motor[backRightWheel] = 50;
		motor[backLeftWheel] = -50;
	}
	//Brief brake to eliminate some drift
	motor[frontRightWheel] = -5;
	motor[frontLeftWheel] = 5;
	motor[backRightWheel] = -5;
	motor[backLeftWheel] = 5;
	wait1Msec(100);
	//}
	//else
	//{
	//	while(abs(SensorValue[gyro]) < degrees10 - 100)
	//	{
	//		motor[frontRightWheel] = 50;
	//		motor[frontLeftWheel] = -50;
	//		motor[backRightWheel] = 50;
	//		motor[backLeftWheel] = -50;
	//	}
	//	//Brief brake to eliminate some drift
	//	motor[frontRightWheel] = -5;
	//	motor[frontLeftWheel] = 5;
	//	motor[backRightWheel] = -5;
	//	motor[backLeftWheel] = 5;
	//	wait1Msec(100);
	//}

	while(abs(SensorValue[gyroDrive]) < degrees10 - 100)
	{
		motor[frontRightWheel] = 50;
		motor[frontLeftWheel] = -50;
		motor[backRightWheel] = 50;
		motor[backLeftWheel] = -50;
	}
	//Brief brake to eliminate some drift
	motor[frontRightWheel] = -5;
	motor[frontLeftWheel] = 5;
	motor[backRightWheel] = -5;
	motor[backLeftWheel] = 5;
	wait1Msec(100);

	//Second while loop to move the robot more slowly to its goal, also setting up a range
	//for the amount of acceptable error in the system
	while(abs(SensorValue[gyroDrive]) > degrees10 + error || abs(SensorValue[gyroDrive]) < degrees10 - error)
	{
		if(abs(SensorValue[gyroDrive]) > degrees10)
		{
			motor[frontRightWheel] = -30;
			motor[frontLeftWheel] = 30;
			motor[backRightWheel] = -30;
			motor[backLeftWheel] = 30;
		}
		else
		{
			motor[frontRightWheel] = 30;
			motor[frontLeftWheel] = -30;
			motor[backRightWheel] = 30;
			motor[backLeftWheel] = -30;
		}
	}
	//Stop
	motor[frontRightWheel]=0;
	motor[frontLeftWheel] =0;
	motor[backRightWheel] =0;
	motor[backLeftWheel]  =0;
	wait1Msec(250);
}

void clearEncoder()
{
	nMotorEncoder[frontLeftWheel]=0;
	nMotorEncoder[backLeftWheel]=0;
	nMotorEncoder[frontRightWheel]=0;
	nMotorEncoder[backRightWheel]=0;
}


void moveStraight(int power, int counts)
{
	clearEncoder();
	if (counts > 0)
	{
		//move foreward
		while (nMotorEncoder[frontRightWheel ]< counts)
		{
			motor[frontLeftWheel]=power;
			motor[backLeftWheel]=power;
			motor[frontRightWheel]=power;
			motor[backRightWheel]=power;
		}
	}
	else
	{
		//move backwards
		while (nMotorEncoder[frontRightWheel ]> counts)
		{
			motor[frontLeftWheel]=power;
			motor[backLeftWheel]=power;
			motor[frontRightWheel]=power;
			motor[backRightWheel]=power;
		}
	}
}

void moveSideways(int power, int counts)
{
	clearEncoder();
	if (counts > 0)
	{
		//move left
		while (nMotorEncoder[frontRightWheel ]< counts)
		{
			motor[frontLeftWheel]=-power;
			motor[backLeftWheel]=power;
			motor[frontRightWheel]=power;
			motor[backRightWheel]=-power;
		}
	}
	else
	{
		//move right
		while (nMotorEncoder[frontRightWheel ]> counts)
		{
			motor[frontLeftWheel]=-power;
			motor[backLeftWheel]=power;
			motor[frontRightWheel]=power;
			motor[backRightWheel]=-power;
		}
	}

}
